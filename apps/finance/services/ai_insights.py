# ==============================================================================
# File: apps/finance/services/ai_insights.py
# Project: Whole Life Journey - Django 5.x Personal Wellness/Journaling App
# Description: AI-powered spending insights and financial coaching
# Owner: Danny Jenkins (dannyjenkins71@gmail.com)
# Created: 2026-01-03
# Last Updated: 2026-01-03
# ==============================================================================
"""
Finance AI Insights Service

Provides AI-generated financial insights following the rules in
docs/wlj_ai_finance_rules.md:

- Spending summaries and trend analysis
- Unusual spending pattern detection
- Recurring subscription identification
- Goal-aligned recommendations

Security:
    - Aggregates data before sending to AI (no raw transaction details)
    - Verifies user consent before AI processing
    - Never provides financial advice
    - Includes explainability in all insights
"""

import logging
from datetime import timedelta
from decimal import Decimal
from typing import Optional, Dict, List, Any

from django.core.cache import cache
from django.db.models import Sum, Count, Avg, Q
from django.utils import timezone

from apps.ai.services import AIService

logger = logging.getLogger(__name__)


# Standard disclaimer for all finance AI insights
FINANCE_AI_DISCLAIMER = (
    "This insight is generated by AI based on the transactions you've logged. "
    "It is not financial advice. For investment, tax, or debt decisions, "
    "please consult a qualified financial professional."
)


class FinanceAIService:
    """
    AI-powered financial insights service.

    Generates spending insights, pattern detection, and supportive
    recommendations while following the Finance AI Rules.
    """

    def __init__(self, user):
        """
        Initialize the Finance AI service.

        Args:
            user: Django User instance
        """
        self.user = user
        self.prefs = user.preferences
        self.ai_service = AIService()

    # =========================================================================
    # CONSENT AND CONFIGURATION
    # =========================================================================

    def check_consent(self) -> bool:
        """
        Check if user has consented to AI processing of financial data.

        Returns:
            bool: True if consent given, False otherwise
        """
        return (
            self.ai_service.check_user_consent(self.user) and
            self.prefs.finance_enabled and
            not getattr(self.prefs, 'finance_ai_disabled', False)
        )

    @property
    def faith_enabled(self) -> bool:
        """Check if faith context should be included."""
        return getattr(self.prefs, 'faith_enabled', False)

    @property
    def coaching_style(self) -> str:
        """Get user's preferred coaching style."""
        return getattr(self.prefs, 'ai_coaching_style', 'supportive')

    # =========================================================================
    # DATA AGGREGATION (Privacy-First)
    # =========================================================================

    def _get_spending_summary(self, days: int = 30) -> Dict[str, Any]:
        """
        Get aggregated spending summary for AI processing.

        Follows AI Finance Rules - aggregates data, never sends raw transactions.

        Args:
            days: Number of days to analyze

        Returns:
            dict: Aggregated spending data safe for AI processing
        """
        from apps.finance.models import Transaction, Budget, FinancialGoal
        from apps.core.utils import get_user_today

        today = get_user_today(self.user)
        start_date = today - timedelta(days=days)
        month_start = today.replace(day=1)

        # Get transaction aggregates
        transactions = Transaction.objects.filter(
            user=self.user,
            status='active',
            date__gte=start_date,
            date__lte=today,
            is_opening_balance=False
        ).exclude(transfer_pair__isnull=False)

        # Income vs expenses
        income = transactions.filter(amount__gt=0).aggregate(
            total=Sum('amount'),
            count=Count('id')
        )
        expenses = transactions.filter(amount__lt=0).aggregate(
            total=Sum('amount'),
            count=Count('id')
        )

        total_income = abs(income['total'] or Decimal('0'))
        total_expenses = abs(expenses['total'] or Decimal('0'))

        # Category breakdown (top 5 expense categories)
        category_spending = transactions.filter(
            amount__lt=0,
            category__isnull=False
        ).values('category__name').annotate(
            total=Sum('amount')
        ).order_by('total')[:5]

        top_categories = [
            {'name': c['category__name'], 'amount': abs(c['total'])}
            for c in category_spending
        ]

        # Budget progress
        budgets = Budget.objects.filter(
            user=self.user,
            status='active',
            month=month_start
        ).select_related('category')

        budget_summary = []
        for budget in budgets[:5]:
            budget_summary.append({
                'category': budget.category.name if budget.category else 'Unknown',
                'budgeted': float(budget.budgeted_amount),
                'spent': float(budget.spent_amount),
                'percentage': budget.percentage_used,
            })

        # Active financial goals
        goals = FinancialGoal.objects.filter(
            user=self.user,
            status='active',
            goal_status='active'
        )[:3]

        goal_summary = [
            {
                'name': g.name,
                'progress': g.progress_percentage,
                'remaining': float(g.target_amount - g.current_amount),
            }
            for g in goals
        ]

        # Calculate savings rate
        if total_income > 0:
            savings_rate = ((total_income - total_expenses) / total_income) * 100
        else:
            savings_rate = 0

        return {
            'period_days': days,
            'total_income': float(total_income),
            'total_expenses': float(total_expenses),
            'net_cash_flow': float(total_income - total_expenses),
            'savings_rate': round(savings_rate, 1),
            'transaction_count': (income['count'] or 0) + (expenses['count'] or 0),
            'top_expense_categories': top_categories,
            'budget_summary': budget_summary,
            'active_goals': goal_summary,
        }

    def _get_spending_trends(self) -> Dict[str, Any]:
        """
        Get spending trend data comparing current vs previous period.

        Returns:
            dict: Trend comparison data
        """
        from apps.finance.models import Transaction
        from apps.core.utils import get_user_today

        today = get_user_today(self.user)

        # Current month
        month_start = today.replace(day=1)
        current_month = Transaction.objects.filter(
            user=self.user,
            status='active',
            date__gte=month_start,
            date__lte=today,
            amount__lt=0,
            is_opening_balance=False
        ).exclude(transfer_pair__isnull=False).aggregate(
            total=Sum('amount'),
            count=Count('id')
        )

        # Previous month (same day range)
        prev_month_start = (month_start - timedelta(days=1)).replace(day=1)
        prev_month_end = month_start - timedelta(days=1)
        # Adjust to same relative day
        days_into_month = (today - month_start).days
        prev_compare_end = prev_month_start + timedelta(days=days_into_month)

        prev_month = Transaction.objects.filter(
            user=self.user,
            status='active',
            date__gte=prev_month_start,
            date__lte=prev_compare_end,
            amount__lt=0,
            is_opening_balance=False
        ).exclude(transfer_pair__isnull=False).aggregate(
            total=Sum('amount'),
            count=Count('id')
        )

        current_spending = abs(current_month['total'] or Decimal('0'))
        prev_spending = abs(prev_month['total'] or Decimal('0'))

        if prev_spending > 0:
            change_percent = ((current_spending - prev_spending) / prev_spending) * 100
        else:
            change_percent = 0

        return {
            'current_month_spending': float(current_spending),
            'previous_month_spending': float(prev_spending),
            'change_percent': round(change_percent, 1),
            'trend': 'up' if change_percent > 5 else ('down' if change_percent < -5 else 'stable'),
            'days_into_month': days_into_month + 1,
        }

    def _detect_unusual_spending(self) -> List[Dict[str, Any]]:
        """
        Detect unusual spending patterns.

        Compares recent spending to historical averages.

        Returns:
            list: Unusual spending patterns detected
        """
        from apps.finance.models import Transaction
        from apps.core.utils import get_user_today

        today = get_user_today(self.user)
        week_ago = today - timedelta(days=7)
        month_ago = today - timedelta(days=30)

        unusual = []

        # Get category averages over 30 days
        category_monthly = Transaction.objects.filter(
            user=self.user,
            status='active',
            date__gte=month_ago,
            date__lte=today,
            amount__lt=0,
            category__isnull=False,
            is_opening_balance=False
        ).exclude(transfer_pair__isnull=False).values('category__name').annotate(
            total=Sum('amount')
        )

        category_averages = {
            c['category__name']: abs(c['total']) / 4  # Weekly average
            for c in category_monthly
        }

        # Get this week's spending by category
        category_weekly = Transaction.objects.filter(
            user=self.user,
            status='active',
            date__gte=week_ago,
            date__lte=today,
            amount__lt=0,
            category__isnull=False,
            is_opening_balance=False
        ).exclude(transfer_pair__isnull=False).values('category__name').annotate(
            total=Sum('amount')
        )

        # Compare to averages
        for cat in category_weekly:
            cat_name = cat['category__name']
            weekly_spend = abs(cat['total'])
            weekly_avg = category_averages.get(cat_name, 0)

            if weekly_avg > 0:
                deviation = ((weekly_spend - weekly_avg) / weekly_avg) * 100
                if deviation > 50:  # 50% above average
                    unusual.append({
                        'category': cat_name,
                        'this_week': float(weekly_spend),
                        'weekly_average': float(weekly_avg),
                        'deviation_percent': round(deviation, 0),
                        'type': 'high',
                    })

        return unusual[:3]  # Return top 3

    def _identify_recurring_transactions(self) -> List[Dict[str, Any]]:
        """
        Identify potential recurring transactions/subscriptions.

        Returns:
            list: Potential recurring transactions
        """
        from apps.finance.models import Transaction
        from apps.core.utils import get_user_today

        today = get_user_today(self.user)
        months_ago = today - timedelta(days=90)

        # Find descriptions that appear multiple times
        recurring = Transaction.objects.filter(
            user=self.user,
            status='active',
            date__gte=months_ago,
            amount__lt=0,
            is_opening_balance=False
        ).exclude(transfer_pair__isnull=False).values(
            'description'
        ).annotate(
            count=Count('id'),
            total=Sum('amount'),
            avg_amount=Avg('amount')
        ).filter(count__gte=2).order_by('-count')[:5]

        subscriptions = []
        for r in recurring:
            avg_monthly = abs(r['total']) / 3  # 3 months
            subscriptions.append({
                'description': r['description'][:30],  # Truncate for privacy
                'occurrences': r['count'],
                'avg_monthly_cost': float(avg_monthly),
            })

        return subscriptions

    # =========================================================================
    # AI INSIGHT GENERATION
    # =========================================================================

    def generate_spending_insight(self, force_refresh: bool = False) -> Optional[Dict[str, Any]]:
        """
        Generate an AI-powered spending insight.

        Returns cached insight if available and not expired.

        Args:
            force_refresh: Force regeneration of insight

        Returns:
            dict: Insight with text, data, and metadata
        """
        if not self.check_consent():
            logger.info(f"Finance AI disabled or no consent for user {self.user.id}")
            return None

        if not self.ai_service.is_available:
            logger.warning("AI service not available")
            return None

        # Check cache
        cache_key = f'finance_insight_{self.user.id}'
        if not force_refresh:
            cached = cache.get(cache_key)
            if cached:
                return cached

        # Gather aggregated data
        summary = self._get_spending_summary(30)
        trends = self._get_spending_trends()
        unusual = self._detect_unusual_spending()

        # Build AI prompt
        system_prompt = self._build_system_prompt()
        user_prompt = self._build_spending_insight_prompt(summary, trends, unusual)

        # Call AI
        insight_text = self.ai_service._call_api(
            system_prompt,
            user_prompt,
            max_tokens=250
        )

        if not insight_text:
            return None

        result = {
            'insight': insight_text,
            'data': {
                'net_cash_flow': summary['net_cash_flow'],
                'savings_rate': summary['savings_rate'],
                'trend': trends['trend'],
                'change_percent': trends['change_percent'],
            },
            'generated_at': timezone.now().isoformat(),
            'disclaimer': FINANCE_AI_DISCLAIMER,
            'data_source': f"Based on {summary['transaction_count']} transactions over the past 30 days",
        }

        # Cache for 4 hours
        cache.set(cache_key, result, 14400)

        return result

    def generate_budget_alert(self, budget) -> Optional[str]:
        """
        Generate a supportive budget alert message.

        Args:
            budget: Budget model instance

        Returns:
            str: AI-generated alert message
        """
        if not self.check_consent():
            return None

        if not self.ai_service.is_available:
            return None

        system_prompt = self._build_system_prompt()
        user_prompt = f"""The user has a budget for "{budget.category.name}" set at ${budget.budgeted_amount:.2f}.
They've spent ${budget.spent_amount:.2f} so far, which is {budget.percentage_used}% of their budget.
{'They are over budget.' if budget.percentage_used > 100 else f"There are approximately {30 - (timezone.now().day)} days left in the month."}

Generate a brief (2-3 sentences), supportive observation about this budget.
- If over budget: acknowledge without judgment, focus on awareness
- If near budget: gentle awareness
- If on track: brief encouragement

Use observation language ("It looks like...", "Your data shows...") not advice language."""

        return self.ai_service._call_api(
            system_prompt,
            user_prompt,
            max_tokens=100
        )

    def generate_goal_encouragement(self, goal) -> Optional[str]:
        """
        Generate encouraging message for a financial goal.

        Args:
            goal: FinancialGoal model instance

        Returns:
            str: AI-generated encouragement
        """
        if not self.check_consent():
            return None

        if not self.ai_service.is_available:
            return None

        system_prompt = self._build_system_prompt()
        user_prompt = f"""The user has a savings goal called "{goal.name}".
Target: ${goal.target_amount:.2f}
Current: ${goal.current_amount:.2f}
Progress: {goal.progress_percentage}%
{'Target date: ' + goal.target_date.strftime('%B %Y') if goal.target_date else 'No target date set.'}

Generate a brief (2-3 sentences) encouraging observation about their progress.
- Celebrate any progress made
- If they have a target date, note if they're on track without being prescriptive
- Focus on the positive journey, not just the destination

Use observation language, not advice."""

        return self.ai_service._call_api(
            system_prompt,
            user_prompt,
            max_tokens=100
        )

    def generate_subscription_review(self) -> Optional[Dict[str, Any]]:
        """
        Generate a subscription/recurring spending review.

        Returns:
            dict: Review with insights and data
        """
        if not self.check_consent():
            return None

        if not self.ai_service.is_available:
            return None

        subscriptions = self._identify_recurring_transactions()
        if not subscriptions:
            return None

        total_monthly = sum(s['avg_monthly_cost'] for s in subscriptions)

        system_prompt = self._build_system_prompt()
        user_prompt = f"""The user appears to have these recurring expenses (identified from transaction patterns):

{chr(10).join([f"- {s['description']}: ~${s['avg_monthly_cost']:.2f}/month" for s in subscriptions])}

Estimated total: ~${total_monthly:.2f}/month

Generate a brief (2-3 sentences) observation about their recurring expenses.
- Note the total without judgment
- Suggest it might be worth reviewing periodically
- Do NOT recommend canceling any specific service

Use neutral, observational language."""

        insight = self.ai_service._call_api(
            system_prompt,
            user_prompt,
            max_tokens=150
        )

        if not insight:
            return None

        return {
            'insight': insight,
            'subscriptions': subscriptions,
            'estimated_monthly_total': total_monthly,
            'disclaimer': FINANCE_AI_DISCLAIMER,
        }

    # =========================================================================
    # PROMPT BUILDING
    # =========================================================================

    def _build_system_prompt(self) -> str:
        """
        Build the system prompt for finance AI interactions.

        Follows AI Finance Rules for safe, observation-based responses.
        """
        base = """You are a supportive financial awareness assistant for "Whole Life Journey," a personal wellness app.

Your role is to provide observations about spending patterns - NOT financial advice.

STRICT RULES:
1. NEVER provide investment, tax, debt, or savings recommendations
2. NEVER tell users what they "should" or "must" do
3. NEVER recommend specific financial products or strategies
4. ALWAYS use observational language: "It looks like...", "Your data shows...", "Based on your transactions..."
5. ALWAYS be supportive and non-judgmental
6. Acknowledge patterns without prescribing solutions
7. Celebrate progress genuinely

If asked for advice, respond with: "I can only share observations about your spending patterns. For financial advice, please consult a qualified financial professional."
"""

        # Add coaching style context
        if self.coaching_style == 'gentle':
            base += "\n\nYour tone is especially gentle and warm - like a caring friend."
        elif self.coaching_style == 'direct':
            base += "\n\nYour tone is direct but still supportive - clear observations without fluff."
        else:  # supportive (default)
            base += "\n\nYour tone is balanced - warm and encouraging while being honest."

        # Add faith context if enabled
        if self.faith_enabled:
            base += """

FAITH CONTEXT: The user has faith/spirituality enabled. You may:
- Reference concepts of stewardship when naturally relevant
- Acknowledge gratitude as a financial mindset
- Keep it natural - don't force religious language"""

        return base

    def _build_spending_insight_prompt(
        self,
        summary: Dict[str, Any],
        trends: Dict[str, Any],
        unusual: List[Dict[str, Any]]
    ) -> str:
        """
        Build the user prompt for spending insight generation.
        """
        prompt = f"""Here is the user's spending data for the past 30 days:

OVERVIEW:
- Total income: ${summary['total_income']:,.2f}
- Total expenses: ${summary['total_expenses']:,.2f}
- Net cash flow: ${summary['net_cash_flow']:+,.2f}
- Savings rate: {summary['savings_rate']}%

TOP EXPENSE CATEGORIES:
"""
        for cat in summary['top_expense_categories'][:3]:
            prompt += f"- {cat['name']}: ${cat['amount']:,.2f}\n"

        prompt += f"""
TREND:
- This month vs last month: {trends['change_percent']:+.1f}% ({trends['trend']})
- Days into month: {trends['days_into_month']}
"""

        if unusual:
            prompt += "\nNOTABLE PATTERNS:\n"
            for u in unusual:
                prompt += f"- {u['category']} is {u['deviation_percent']:.0f}% above weekly average\n"

        if summary['budget_summary']:
            prompt += "\nBUDGET STATUS:\n"
            for b in summary['budget_summary'][:3]:
                prompt += f"- {b['category']}: {b['percentage']:.0f}% used (${b['spent']:.0f}/${b['budgeted']:.0f})\n"

        if summary['active_goals']:
            prompt += "\nACTIVE GOALS:\n"
            for g in summary['active_goals']:
                prompt += f"- {g['name']}: {g['progress']}% complete\n"

        prompt += """
Generate a brief (3-4 sentences), personalized spending observation.
Include:
1. One key observation about their overall financial picture
2. One specific pattern you noticed (good or needs awareness)
3. An encouraging closing thought

Remember: observations only, not advice. Use "It looks like..." or "Your data shows..." language."""

        return prompt


# Convenience function for easy access
_finance_ai_service = None


def get_finance_ai_service(user):
    """Get a FinanceAIService instance for the given user."""
    return FinanceAIService(user)
